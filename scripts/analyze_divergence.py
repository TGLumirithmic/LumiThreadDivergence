#!/usr/bin/env python3
"""
Analyze and visualize warp divergence metrics from OptiX rendering.

This script reads divergence profiling data from a binary file generated by
the instrumented OptiX renderer and creates visualizations showing divergence
hotspots across different program stages.

Usage:
    python analyze_divergence.py <divergence.bin>
"""

import numpy as np
import matplotlib.pyplot as plt
import sys
import os

def load_divergence_metrics(filepath):
    """
    Load divergence metrics from binary file.

    File format:
        - Header (3 uint32): [width, height, num_metrics]
        - Data (width * height * num_metrics uint32): divergence counters

    Returns:
        data: numpy array of shape (height, width, num_metrics)
        width: image width
        height: image height
        num_metrics: number of divergence metrics
    """
    with open(filepath, 'rb') as f:
        # Read header
        header = np.fromfile(f, dtype=np.uint32, count=3)
        width, height, num_metrics = header

        print(f"Loading divergence data: {width}x{height}, {num_metrics} metrics")

        # Read divergence data
        data = np.fromfile(f, dtype=np.uint32)
        expected_size = width * height * num_metrics

        if len(data) != expected_size:
            raise ValueError(f"Data size mismatch: expected {expected_size}, got {len(data)}")

        data = data.reshape((height, width, num_metrics))

    return data, int(width), int(height), int(num_metrics)

def visualize_divergence(data, width, height, metric_names, output_prefix='divergence'):
    """
    Create heatmaps for each divergence metric.

    Args:
        data: numpy array of shape (height, width, num_metrics)
        width: image width
        height: image height
        metric_names: list of metric names
        output_prefix: prefix for output filenames
    """
    num_metrics = data.shape[2]

    # Create figure with subplots (3x3 grid for 9 metrics)
    fig, axes = plt.subplots(3, 3, figsize=(20, 15))
    axes = axes.flatten()

    for i in range(num_metrics):
        metric = data[:, :, i]

        # Special handling for instance entropy (metric 8) - stored as fixed-point
        if i == 8:  # Instance Entropy
            metric = metric / 1000.0  # Convert from fixed-point to float

        # Create heatmap
        im = axes[i].imshow(metric, cmap='hot', interpolation='nearest', aspect='auto')

        # Special title formatting for entropy
        if i == 8:
            axes[i].set_title(f'{metric_names[i]}\nMax: {metric.max():.3f} bits, Mean: {metric.mean():.3f} bits',
                             fontsize=12, fontweight='bold')
        else:
            axes[i].set_title(f'{metric_names[i]}\nMax: {metric.max()}, Mean: {metric.mean():.1f}',
                             fontsize=12, fontweight='bold')
        axes[i].axis('off')

        # Add colorbar
        cbar = plt.colorbar(im, ax=axes[i], fraction=0.046, pad=0.04)
        if i == 8:
            cbar.set_label('Entropy (bits)', fontsize=10)
        else:
            cbar.set_label('Divergence Count', fontsize=10)

    # Hide unused subplots
    for i in range(num_metrics, len(axes)):
        axes[i].axis('off')

    plt.tight_layout()

    # Save figure
    output_file = f'{output_prefix}_heatmap.png'
    plt.savefig(output_file, dpi=150, bbox_inches='tight')
    print(f"\nSaved heatmap to: {output_file}")
    plt.close()

def print_statistics(data, metric_names):
    """
    Print detailed statistics for each divergence metric.

    Args:
        data: numpy array of shape (height, width, num_metrics)
        metric_names: list of metric names
    """
    print("\n" + "=" * 80)
    print("WARP DIVERGENCE STATISTICS")
    print("=" * 80)
    print(f"{'Metric':<25} {'Max':>10} {'Mean':>10} {'Median':>10} {'Total':>15}")
    print("-" * 80)

    total_divergence = 0

    for i, name in enumerate(metric_names):
        metric = data[:, :, i]
        max_val = metric.max()
        mean_val = metric.mean()
        median_val = np.median(metric)
        sum_val = metric.sum()
        total_divergence += sum_val

        print(f"{name:<25} {max_val:>10d} {mean_val:>10.1f} {median_val:>10.1f} {sum_val:>15d}")

    print("-" * 80)
    print(f"{'TOTAL DIVERGENCE':<25} {'':<10} {'':<10} {'':<10} {total_divergence:>15d}")
    print("=" * 80)

    # Calculate percentages
    print("\nDivergence Distribution:")
    print("-" * 80)
    for i, name in enumerate(metric_names):
        metric = data[:, :, i]
        percentage = (metric.sum() / total_divergence * 100) if total_divergence > 0 else 0
        print(f"{name:<25} {percentage:>6.2f}%")
    print("=" * 80)

def analyze_hotspots(data, metric_names, top_n=10):
    """
    Find and display pixels with highest divergence for each metric.

    Args:
        data: numpy array of shape (height, width, num_metrics)
        metric_names: list of metric names
        top_n: number of top hotspots to display
    """
    print("\n" + "=" * 80)
    print(f"TOP {top_n} DIVERGENCE HOTSPOTS BY METRIC")
    print("=" * 80)

    for i, name in enumerate(metric_names):
        metric = data[:, :, i]

        # Find top N pixels
        flat_indices = np.argsort(metric.flatten())[-top_n:][::-1]
        y_coords = flat_indices // metric.shape[1]
        x_coords = flat_indices % metric.shape[1]
        values = metric.flatten()[flat_indices]

        print(f"\n{name}:")
        print(f"  {'Rank':<6} {'X':>6} {'Y':>6} {'Divergence':>12}")
        print("  " + "-" * 32)

        for rank, (x, y, val) in enumerate(zip(x_coords, y_coords, values), 1):
            if val > 0:  # Only show non-zero divergence
                print(f"  {rank:<6} {x:>6} {y:>6} {val:>12d}")

def main():
    if len(sys.argv) < 2:
        print("Usage: python analyze_divergence.py <divergence.bin> [output_prefix]")
        print("\nExample:")
        print("  python analyze_divergence.py output/neural_render_divergence.bin")
        sys.exit(1)

    divergence_file = sys.argv[1]

    # Check if file exists
    if not os.path.exists(divergence_file):
        print(f"Error: File not found: {divergence_file}")
        sys.exit(1)

    # Optional output prefix
    if len(sys.argv) > 2:
        output_prefix = sys.argv[2]
    else:
        # Use divergence file name without extension
        output_prefix = os.path.splitext(divergence_file)[0]

    # Metric names matching the order in programs/common.h
    metric_names = [
        'Raygen',
        'Intersection',
        'Closest-Hit',
        'Shadow Ray',
        'Hash Encoding',
        'MLP Forward',
        'Early Rejection',
        'Hit/Miss',
        'Instance Entropy'
    ]

    # Load divergence data
    print(f"Loading divergence metrics from: {divergence_file}")
    data, width, height, num_metrics = load_divergence_metrics(divergence_file)

    if num_metrics != len(metric_names):
        print(f"Warning: Expected {len(metric_names)} metrics, got {num_metrics}")
        metric_names = metric_names[:num_metrics]

    # Print statistics
    print_statistics(data, metric_names)

    # Visualize divergence heatmaps
    visualize_divergence(data, width, height, metric_names, output_prefix)

    # Analyze hotspots
    analyze_hotspots(data, metric_names, top_n=10)

    print("\n" + "=" * 80)
    print("Analysis complete!")
    print("=" * 80)

if __name__ == '__main__':
    main()
