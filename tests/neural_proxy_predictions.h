/**
 * Neural Proxy Predictions Binary Format
 *
 * This header defines the binary format for neural proxy prediction data
 * generated by stratified_sample_and_predict.py
 */

#pragma once

#include <cstdint>
#include <vector>
#include <string>
#include <fstream>
#include <stdexcept>

namespace neural_proxy {

// Magic number for file validation ("NRTP" = Neural Ray Tracing Predictions)
constexpr uint32_t MAGIC_NUMBER = 0x4E525450;
constexpr uint32_t FORMAT_VERSION = 2;  // Version 2: Added hash_grid and direction_encodings support
constexpr size_t MESH_NAME_SIZE = 256;

/**
 * File header structure (288 bytes total)
 *
 * NOTE: Includes explicit padding for alignment.
 * After has_direction_encodings, there is 1 padding byte to align
 * dfl_num_edges to a 4-byte boundary.
 */
struct Header {
    uint32_t magic;                      // Magic number (0x4E525450)
    uint32_t version;                    // Format version (2)
    uint32_t num_samples;                // Number of samples in file
    uint8_t has_visibility;              // 1 if visibility predictions present
    uint8_t has_depth;                   // 1 if depth predictions present
    uint8_t has_normal;                  // 1 if normal predictions present
    uint8_t has_kd;                      // 1 if kd predictions present
    uint8_t kd_uses_dfl;                 // 1 if kd uses distributed focal loss
    uint8_t has_hash_grid;               // 1 if hash grid intermediate features stored
    uint8_t has_direction_encodings;     // 1 if intermediate direction encodings stored
    uint8_t padding;                     // Padding for alignment (1 byte)
    uint32_t dfl_num_edges;              // Number of DFL bin edges (0 if not using DFL)
    uint32_t hash_grid_dim;              // Hash grid feature dimension (0 if not using hash grid)
    char mesh_name[MESH_NAME_SIZE];      // Mesh name (null-terminated)
};

/**
 * Per-sample prediction data
 *
 * NOTE: The binary file includes explicit padding for alignment.
 * After the three uint8_t fields, there is 1 byte of padding
 * to align the following float to a 4-byte boundary.
 */
struct Sample {
    // Input data
    float origin[3];         // Ray origin (x, y, z)
    float direction[3];      // Ray direction (x, y, z)
    uint32_t grid_idx[3];    // Grid indices (i, j, k)
    uint32_t face_id;        // Face ID
    uint8_t theta_idx;       // Theta index (hemisphere)
    uint8_t phi_idx;         // Phi index (hemisphere)
    uint8_t hit;             // Ground truth hit (0 or 1)
    uint8_t padding;         // Explicit padding byte for alignment

    // Predictions (optional based on header flags)
    float visibility_logit;              // Visibility logit (if has_visibility)
    float depth;                         // Predicted depth (if has_depth)
    float normal[3];                     // Predicted normal (if has_normal)
    std::vector<float> kd;               // Predicted kd RGB (if has_kd && !kd_uses_dfl)
    std::vector<float> kd_logits;        // Kd logits for DFL (if has_kd && kd_uses_dfl)
    std::vector<float> hash_grid;        // hash grid features if has_hash_grid
    std::vector<float> direction_encodings;        // direction encodings if has_direction_encodings
};

/**
 * Neural proxy prediction reader
 */
class PredictionReader {
public:
    PredictionReader(const std::string& filename) {
        file_.open(filename, std::ios::binary);
        if (!file_.is_open()) {
            throw std::runtime_error("Failed to open file: " + filename);
        }
        read_header();
    }

    ~PredictionReader() {
        if (file_.is_open()) {
            file_.close();
        }
    }

    const Header& header() const { return header_; }

    /**
     * Read next sample from file
     * Returns false if no more samples available
     */
    bool read_sample(Sample& sample) {
        if (samples_read_ >= header_.num_samples) {
            return false;
        }

        // Read origin
        file_.read(reinterpret_cast<char*>(sample.origin), sizeof(float) * 3);

        // Read direction
        file_.read(reinterpret_cast<char*>(sample.direction), sizeof(float) * 3);

        // Read grid indices
        file_.read(reinterpret_cast<char*>(sample.grid_idx), sizeof(uint32_t) * 3);

        // Read face ID
        file_.read(reinterpret_cast<char*>(&sample.face_id), sizeof(uint32_t));

        // Read hemisphere indices
        file_.read(reinterpret_cast<char*>(&sample.theta_idx), sizeof(uint8_t));
        file_.read(reinterpret_cast<char*>(&sample.phi_idx), sizeof(uint8_t));

        // Read hit
        file_.read(reinterpret_cast<char*>(&sample.hit), sizeof(uint8_t));

        // Read padding byte (for alignment)
        file_.read(reinterpret_cast<char*>(&sample.padding), sizeof(uint8_t));

        // Read predictions based on header flags
        if (header_.has_visibility) {
            file_.read(reinterpret_cast<char*>(&sample.visibility_logit), sizeof(float));
        }

        if (header_.has_depth) {
            file_.read(reinterpret_cast<char*>(&sample.depth), sizeof(float));
        }

        if (header_.has_normal) {
            file_.read(reinterpret_cast<char*>(sample.normal), sizeof(float) * 3);
        }

        if (header_.has_kd) {
            if (header_.kd_uses_dfl) {
                // Read DFL logits
                size_t num_logits = 3 * header_.dfl_num_edges;
                sample.kd_logits.resize(num_logits);
                file_.read(reinterpret_cast<char*>(sample.kd_logits.data()),
                          sizeof(float) * num_logits);
            } else {
                // Read standard kd RGB
                sample.kd.resize(3);
                file_.read(reinterpret_cast<char*>(sample.kd.data()), sizeof(float) * 3);
            }
        }

        if (header_.has_hash_grid) {
            sample.hash_grid.resize(header_.hash_grid_dim);
            file_.read(reinterpret_cast<char*>(sample.hash_grid.data()), sizeof(float) * header_.hash_grid_dim);
        }

        if (header_.has_direction_encodings) {
            sample.direction_encodings.resize(16);
            file_.read(reinterpret_cast<char*>(sample.direction_encodings.data()), sizeof(float) * 16);
        }

        samples_read_++;
        return file_.good();
    }

    /**
     * Read all samples into a vector
     */
    std::vector<Sample> read_all() {
        std::vector<Sample> samples;
        samples.reserve(header_.num_samples);

        Sample sample;
        while (read_sample(sample)) {
            samples.push_back(sample);
        }

        return samples;
    }

private:
    void read_header() {
        // Read header fields individually to ensure correct alignment
        file_.read(reinterpret_cast<char*>(&header_.magic), sizeof(uint32_t));
        file_.read(reinterpret_cast<char*>(&header_.version), sizeof(uint32_t));
        file_.read(reinterpret_cast<char*>(&header_.num_samples), sizeof(uint32_t));
        file_.read(reinterpret_cast<char*>(&header_.has_visibility), sizeof(uint8_t));
        file_.read(reinterpret_cast<char*>(&header_.has_depth), sizeof(uint8_t));
        file_.read(reinterpret_cast<char*>(&header_.has_normal), sizeof(uint8_t));
        file_.read(reinterpret_cast<char*>(&header_.has_kd), sizeof(uint8_t));
        file_.read(reinterpret_cast<char*>(&header_.kd_uses_dfl), sizeof(uint8_t));
        file_.read(reinterpret_cast<char*>(&header_.has_hash_grid), sizeof(uint8_t));
        file_.read(reinterpret_cast<char*>(&header_.has_direction_encodings), sizeof(uint8_t));
        file_.read(reinterpret_cast<char*>(header_.padding), 1);  // Read 3 padding bytes
        file_.read(reinterpret_cast<char*>(&header_.dfl_num_edges), sizeof(uint32_t));
        file_.read(reinterpret_cast<char*>(&header_.hash_grid_dim), sizeof(uint32_t));
        file_.read(reinterpret_cast<char*>(header_.mesh_name), MESH_NAME_SIZE);

        // Validate magic number
        if (header_.magic != MAGIC_NUMBER) {
            throw std::runtime_error("Invalid magic number");
        }

        // Validate version
        if (header_.version != FORMAT_VERSION) {
            throw std::runtime_error("Unsupported format version: " +
                                    std::to_string(header_.version));
        }
    }

    std::ifstream file_;
    Header header_;
    uint32_t samples_read_ = 0;
};

/**
 * Example usage:
 *
 * neural_proxy::PredictionReader reader("predictions.bin");
 * std::cout << "Mesh: " << reader.header().mesh_name << std::endl;
 * std::cout << "Samples: " << reader.header().num_samples << std::endl;
 *
 * neural_proxy::Sample sample;
 * while (reader.read_sample(sample)) {
 *     // Process sample
 *     if (reader.header().has_visibility) {
 *         float visibility = 1.0f / (1.0f + std::exp(-sample.visibility_logit));
 *         // Use visibility...
 *     }
 * }
 */

} // namespace neural_proxy
